# 面向过程

面向过程编程（Procedural Programming）是一种以**步骤和过程**为核心的编程范式（函数式编程），其核心思想是将复杂问题分解为一系列可顺序执行的函数或过程，通过逐步调用来实现整体功能

## 核心思想

- **步骤分解**：将问题拆解为多个子任务，每个子任务由独立的**函数/过程**实现。例如，处理学生早上的活动可分解为“起床→穿衣→洗漱→去学校”等步骤，每个步骤对应一个函数。
- **顺序执行**：程序按代码的书写顺序从上到下执行，通过**条件语句**（如if）和**循环结构**（如for）控制流程
- **数据与操作分离**：数据存储在全局或局部变量中，函数通过参数接收数据并处理，结果通过返回值或修改变量传递。

## 典型特征

- **模块化函数**：功能封装为函数，例如计算两数之和的函数 `add()`，通过调用实现代码复用。
- **线性流程**：程序逻辑清晰，易于调试。例如读取文件数据→处理数据→返回结果。
- **高效性**：适用于简单任务或对性能要求高的场景，因无需对象创建开销。

# 面向对象

面向对象编程（Object-Oriented Programming，**OOP**）是一种以**对象**为核心的编程范式，通过模拟现实世界中事物的交互逻辑来构建程序。其核心思想是将数据与操作数据的方法封装成独立的对象，通过对象之间的协作实现复杂功能

## 核心概念

1. **类（Class）**：定义对象的模板，描述一类事物的**共性特征**（如属性）和**行为**（如方法）。例如，"汽车"类包含属性"颜色"和方法"加速"。
2. **对象（Object）**：类的具体实例，拥有独立的**状态**（属性值）和**行为**。例如，一辆红色汽车是"汽车"类的对象
3. **封装（Encapsulation）**：将数据和方法捆绑在对象内部，仅**通过暴露的接口与外界交互，保护数据安全并简化使用**。例如，银行账户的余额只能通过特定方法修改。
4. **继承（Inheritance）**：**子类**可**复用父类的属性和方法**，并扩展新功能，实现代码复用和逻辑分层。例如，"电动车"类继承自"汽车"类，新增"充电"方法。
5. **多态（Polymorphism）**：**同一方法在不同对象中呈现不同行为**，增强代码灵活性。例如，"动物"类的"发声"方法在"狗"和"猫"对象中分别输出"汪汪"和"喵喵"。
6. **抽象（Abstraction）**：提取共性特征形成接口或抽象类，隐藏复杂实现细节，例如定义"图形"类的抽象方法"计算面积"。

## 核心优势（相对于函数式编程）

- **可维护性**：对象间低耦合，变更某个功能，修改某部分代码不影响整体系统。
- **可扩展性**：通过**继承和多态**灵活扩展功能，无需重写现有代码。
- **复用性**：封装后的类可跨项目重复使用，减少冗余代码。
- **逻辑直观**：以现实世界模型组织代码，更符合人类认知。

# 两者对比

## 面向过程—怎么做

1. 把完成某一个需求的 `所有步骤` `从头到尾` 逐步实现
2. 根据开发需求，将某些功能独立的代码封装成一个又一个函数
3. 最后完成的代码，就是顺序地调用不同的函数

注重步骤与过程，不注重职责和分工，如果需求比较复杂，虽然有函数封装，但是还是会导致代码比较臃肿。开发起来比较复杂。

## 面向对象—谁来做

相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法

1. 在完成某一个需求前，首先确定职责 —— 要做的事情（方法）
2. 根据职责确定不同的对象，在对象内部封装不同的方法（多个）
3. 最后完成的代码，就是顺序地让不同的对象调用不同的方法

**特点**

1. 注重对象和职责，**不同的对象承担不同的职责**。
2. 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路。
3. 需要在面向过程基础上，再学习一些面向对象的语法。



# 类与对象

在面向对象中，类与对象是两个核心的概念

## 类

- 类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能直接使用
- 模板，拥有属性和方法
  - **特征** 被称为 **属性**
  - **行为** 被称为 **方法**
- 类就相当于制造飞机时的图纸，是一个模板，是负责创建对象的。

## 对象

- 对象是由类创建出来的一个具体存在，可以直接使用。
- 由哪一个类创建出来的对象，就拥有在哪一个类中定义的：属性 & 方法。
- 对象就相当于用图纸制造的飞机。

## 类与对象的关系

- 类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象。
- 类只有一个，而对象可以有很多个：不同的对象之间属性可能会各不相同。
- 类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少。

## 类的设计

在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类

在程序开发中，要设计一个类，通常需要满足一下三个要素：

1. **类名** 这类事物的名字，**满足大驼峰命名法**
2. **属性** 这类事物具有什么样的特征
3. **方法** 这类事物具有什么样的行为

**大驼峰命名法**

```python
CapWords
```

**类名的确定**

通常类名的选择，我们应该根据整个业务流程来提取，或者从大的角度来选择

**属性和方法的确定**

- 对对象的特征描述，通常可以定义成属性
- 对象具有的行为，通常可以定义成方法

## 类的定义

类的基本定于语法如下：

```python
class Human:
    '''
    这里可以写上对于这个类的说明
    '''
    变量 = xxxx	# 这里是类的静态属性，也可以理解为该类共有的特性
    dic = {}
    l1 = []
    def __init__(self,xxx,xxx):		# 属性(__init__是实例化对象的初始方法)
        pass
    
    def func(self):					# 方法，动态属性
		pass
```

**示例**：

定义一个人"类"，人类有思想，并且具备姓名，年龄，身高。人类还会吃饭，还会跑步等

```python
class Human(object):	# 默认继承自 object
    """
    此类用来构造人类
    """
    mind = "思考问题.."
    def __init__(self,name,age,height):
    	# 在__init__中，通过self给对象封装属性
        self.name = name
        self.age = age
        self.height = height

    def run(self):
        print('高高兴兴的跑步')

    def eat(self):
        print('大口大口的吃饭')
```

这里的 object 和 self 的解释如下：

**`object` 是 Python 中所有类的基类**。它是所有用户自定义类和内置类的顶层父类。可以理解为所有的类都继承自 object 类，所以才能具备类的初始化等许多基础特性。

`self` 是一个约定俗成的参数名，用于引用类的实例。它代表当前对象的实例，使我们能够访问实例的属性和方法。

**在实例方法中，第一个参数通常命名为 `self`**，但你可以使用其他名称（虽然不推荐）。

## 实例化对象

通过类生成具体的对象的过程，我们称之为实例化。

```python
class Human(object):	# 默认继承自 object
    """
    此类用来构造人类
    """
    mind = "思考问题.."
    def __init__(self,name,age,height):
        self.name = name
        self.age = age
        self.height = height

    def run(self):
        print('高高兴兴的跑步')

    def eat(self):
        print('大口大口的吃饭')
        
# 实例化对象
xiaoming = Human('小明',18, 173.5)
xiaohong = Human('小红',20, 165)
```

这里的小明和小红就是我们通过 Human 这个类实例化出来的具体的对象

其实实例化一个对象总共发生了三件事：

1. 在内存中开辟了一个对象空间。
2. **自动执行类中的 `__init__` 方法**，并**将**这个对象空间（**内存地址**）传给了 `__init__` 方法的第一个位置参数 **self**。
3. 在 `__init__` 方法中通过  self 给对象空间添加属性。


**对象访问类中的属性和方法**

```python
# 访问静态属性
print(xiaoming.mind)
print(xiaohong.name)
print(xiaohong.age)

# 访问动态方法
xiaohong.run()
xiaoming.eat()

```

**查看对象的所有属性**

我们可以通过 object 基类中提供的 `__dict__` 方法来**查看某个对象的属性**。

```python
# 通过对象查看类中所有的属性
print(xiaoming.__dict__)
```

# 从类名的角度研究类

## 类名操作静态属性

查看类中所有的内容，用 `类名.__dict__`

```python
class Human(object):	# 默认继承自 object
    """
    此类用来构造人类
    """
    mind = "思考问题.."
    # 在__init__中，通过self给对象封装属性
    def __init__(self,name,age,height):

        self.name = name
        self.age = age
        self.height = height

    def run(self):
        print('高高兴兴的跑步')

    def eat(self):
        print('大口大口的吃饭')
        
print(Human.__dict__)
print(Human.__dict__['mind'])
Human.__dict__['mind'] = '高智慧'
# 通过这种方式只能查询，不能增删改
print(Human.__dict__)

```

**万能的点 `.`**

在面向对象中，我们更多的是使用 `.` 来获取类或者对象的属性或方法

```python
class Human(object):  # 默认继承自 object
    """
    此类用来构造人类
    """
    mind = "思考问题.."

    def __init__(self, name, age, height):
        # 在__init__中，通过self给对象封装属性
        self.name = name
        self.age = age
        self.height = height

    def run(self):
        print('高高兴兴的跑步')

    def eat(self):
        print('大口大口的吃饭')


print(Human.mind)
Human.mind = '高智慧'
print(Human.mind)

del Human.mind
Human.run = '慢慢悠悠的走路'
print(Human.run)
# 通过万能的点 可以增删改查类中的单个属性
print('大口大口的吃饭')
```

总结：如果想要查看类的内容，我们可以使用`__dict__`方法，如果想要操作类中的某个属性，可以使用`.`

## 类名操作动态方法

```python
class Human(object):  # 默认继承自 object
    """
    此类用来构造人类
    """
    mind = "思考问题.."
    # 在__init__中，通过self给对象封装属性
    def __init__(self, name, age, height):
        self.name = name
        self.age = age
        self.height = height

    def run(self):
        print(self,'高高兴兴的跑步')

    def eat(self):
        print(self,'大口大口的吃饭')

# 可以直接通过human调用动态方法，也可以通过dict为类内部方法传递实参
Human.eat('小明')  #类名.方法(属性....)
print(Human.__dict__) #返回属性和方法，内存地址
Human.__dict__['run']('小红')  
```

# 从对象的角度研究类

## 对象操作对象属性

对象也可以通过 `__dict__` 查看对象的所有属性


```python
class Human(object):  # 默认继承自 object
    """
    此类用来构造人类
    """
    mind = "思考问题.."

    def __init__(self, name, age, height):
        self.name = name
        self.age = age
        self.height = height

    def run(self):
        print('高高兴兴的跑步')

    def eat(self):
        print('大口大口的吃饭')


# 实例化出一个具体的对象
xiaoming = Human('小明', 18, 173.5)
xiaohong = Human('小红', 20, 165)

print(xiaoming.__dict__)
```

同样也可以使用万能的点操作对象属性

```python
class Human(object):  # 默认继承自 object
    """
    此类用来构造人类
    """
    mind = "思考问题.."

    def __init__(self, name, age, height):
        self.name = name
        self.age = age
        self.height = height

    def run(self):
        print('高高兴兴的跑步')

    def eat(self):
        print('大口大口的吃饭')


# 实例化出一个具体的对象
xiaoming = Human('小明', 18, 173.5)
xiaohong = Human('小红', 20, 165)

# 修改属性
xiaoming.name = "小小明"

# 增加属性
xiaoming.sex = "男"
print(xiaoming.sex)

# 删除属性
del xiaoming.height

# 查看属性
print(xiaoming.__dict__)
```

## 对象查看类的属性

```python
class Human(object):  # 默认继承自 object
    """
    此类用来构造人类
    """
    mind = "思考问题.."

    def __init__(self, name, age, height):
        self.name = name
        self.age = age
        self.height = height

    def run(self):
        print('高高兴兴的跑步')

    def eat(self):
        print('大口大口的吃饭')


# 实例化出一个具体的对象
xiaoming = Human('小明', 18, 173.5)
xiaohong = Human('小红', 20, 165)

print(xiaoming.mind)
```

#  类的内置方法

| 方法名     | 作用                                     |
| :--------- | :--------------------------------------- |
| `__new__`  | 创建对象时，会被自动调用                 |
| `__init__` | 对象被初始化时，会被自动调用             |
| `__del__`  | 对象被从内存中销毁前，会被自动调用       |
| `__str__`  | 返回对象的描述信息，`print` 函数输出使用 |
| `__dir__`  | 查看对象内所有属性以及方法               |

# 总结

1. 现有类才有对象，类是模版，对象是通过类实例化出来的。
2. 一个类可以实例化很多个对象。
3. 类中包含静态属性和动态方法，包括内置方法，自定义方法。
4. 实例化对象的时候，会自动调用 `__init__` 来初始化，我们可以在 `__init__` 中定义对象初始化的属性
5. 实例化好的对象可以调用类中的方法或者是静态属性