## python装饰器
> 在不修改函数代码的情况下，动态的修改函数(或方法)的行为，装饰器本质上是一个函数，它接受函数作为参数并返回一个新的函数
应用场景：插入日志、性能测试、事务处理以及缓存等场景

### 案例切入
> 有一个函数``func1()`，作用是输出一段话。我们需要给他增加额外的功能，但不改变原函数

```python
def func1():
    print("在func1()中")

""" 
需求：打印下列内容
hello world
in function1
hello python
"""

# 案例实现
def func2(func):
    def inner():
        print("hello world")
        func()
        print("hello python")
    return inner
func1 = func2(func1)
func1()

```

### 装饰器形成的过程
> 语法糖
> python中的语法糖结构，用于更简便的使用装饰器

```python
# 测试某个函数的执行时间
# 原有代码
import time

def func1():
    print('in func1')

def timer(func):
    def inner():
        start = time.time()
        func()
        print(time.time() - start)
    return inner()

func1 = timer(func1)  # 将dunc1()函数作为参数传出去
func1()

"""
输出
in func1
1.2874603271484375e-05
"""
```
> 使用语法糖来更简便的使用装饰器:
当我们在某个函数上方使用@my_decorator 的时候，python会自动将下面定义的函数作为参数传递给@my_decorator，即func1 = timer(func1)
```python
import time

def timer(func):
    def innner():
        start = time.time()
        func()
        print(time.time() -start)
    return innner
@timer
def func2():
    time.sleep(1)
    print('in func2')
func2()
"""
调试结果
显式执行func2()函数
    ——>输出
    in func2
    1.0043830871582031
"""
```

### 修饰带一个参数的函数
> 与装饰不带参数的函数类似，但需要在装饰器中处理传递给被装饰函数的参数

####  例子
```python
import time

def timer(func):
    def inner(a):
        start = time.time()
        func(a)
        print(time.time() - start)
    return inner

@timer
def func3(a):
    time.sleep(1)
    print(a)
func3("hello_world")

"""
输出
hello_world
1.0029830932617188
"""
```

### 装饰带多个参数的函数
> 利用动态参数进行传参
```python
def my_decorator(func):
    def wrapper(*args,**kwargs):
        print(f"调用{func.__name__}函数返回：位置参数：{args}，关键字参数：{kwargs}") # 打印调用的函数、传入的参数（此处没有用到关键字参数，所以打印的kwargs参数为空）
        result = func(*args,**kwargs)                                       # 调用原始函数并获取结果
        print(f"{func.__name__}函数返回：{result}")                           # 打印返回结果
        return result
    return wrapper

@my_decorator
def add(x,y):
    return x + y

result = add(3,4)
print(f"最终结果：{result}")
"""
    输出结果
调用add函数返回：参数：(3, 4)，关键字参数：{}
add函数返回：7
最终结果：7
"""
```
### wraps装饰器
> 回顾最开始的案例
```python
import time
def func1():
    print('in func1')

def timer(func):
    def inner():
        start = time.time()
        func()
        print(time.time() - start)
    return inner
func1 = timer(func1) # 将函数本身作为参数传递进去
func1()
```
> 问题1——>最后执行的`func1`函数和最初的`func1`是否为同一个函数?

```python
#问题1 解法：打印函数名

import time
def func1():
    print('in func1')

def timer(func):
    def inner():
        start = time.time()
        func()
        print(time.time() - start)
    return inner
func1 = timer(func1)
print(func1.__name__)
"""
输出
inner
"""
```

#### 导入wraps装饰器
> `wraps`装饰器，用于帮助创建装饰器时保留被装饰函数的元数据（如名称、文档字符串等）
使用`@wraps`可以确保装饰后的函数看起来像原始函数，这样有助于调试和文档生成

- 使用wrap装饰器装饰上方案例
```python
from functools import wraps
import time

def func1():
    print('in func1')

def timer(func):
    @wraps(func)
    def innner():
        start = time.time()
        func()
        print(time.time() - start)
    return innner
func1 = timer(func1)
print(func1.__name__)
"""
输出
func1
"""

```

### 带参数的装饰器
>- 带参数的装饰器允许你在装饰器中接受参数，从而增强装饰器的灵活性和功能性
>- 实现带参数的装饰器通常需要使用嵌套函数
本案例将创建一个装饰器，他接受一个参数，用于指定**是否打印函数的执行时间**

```python
import time
from functools import wraps

def timing_decorator(print_time=True):
    def decorator(func):
        @wraps(func)
        def wrapper(*args,**kwargs):
            start_time = time.time()
            result = func(*args,**kwargs)
            end_time = time.time()
            if print_time:
                execution_time = end_time - start_time
                print(f"{func.__name__} 执行时间：{execution_time:.4f}秒")
            return result
        return wrapper
    return decorator
@timing_decorator(print_time=True)
def add(x,y):
    time.sleep(1)
    return(x+y)

@timing_decorator(print_time=False)
def multiply(x,y):
    time.sleep(1)
    return x * y

result_add = add(3,6)
print(f"加法结果为：{result_add}")
result_mutiply = multiply(6,7)
print(f"乘法结果为：{result_mutiply}")
"""
    输出结果
print(f"加法结果为：{result_add}")
result_mutiply = multiply(6,7)
print(f"乘法结果为：{result_mutiply}")
add 执行时间：1.0070秒
>>> print(f"加法结果为：{result_add}")
加法结果为：9
>>> result_mutiply = multiply(6,7)
>>> print(f"乘法结果为：{result_mutiply}")
乘法结果为：42
"""
```
### 多个装饰器装饰同一个函数(装饰器执行的顺序)
> 在这种情况下，装饰从上往下，执行从外到内
```python
def decorator1(func):
    print("decorator1 被应用")
    def wrapper1():
        print("进入 decorator1")
        func()  # ← 这里的 func 是被它包装的函数
        print("退出 decorator1")
    return wrapper1

def decorator2(func):
    print("decorator2 被应用")
    def wrapper2():
        print("进入 decorator2")
        func()  # ← 这里的 func 是被它包装的函数
        print("退出 decorator2")
    return wrapper2

@decorator1
@decorator2
def f():
    print("hello")

f()
"""
    输出
decorator2 被应用
decorator1 被应用
>>> f()
进入 decorator1
进入 decorator2
hello
退出 decorator2
退出 decorator1
"""
```
```txt
f = decorator2(f) -> func = f,return inner2
f = decorator1(f) -> func = inner2,return inner1
f() = inner1() -> inner2() -> f() -> inner2() -> inner1()

       f()
        ↓
   [decorator1]   ← 最外层
        ↓
   [decorator2]   ← 中间层
        ↓
     原始函数     ← 最内层
```
#### 示例
> 创建两个装饰器，一个用于打印函数执行时间，另一个用于打印调用参数
```
import time
from functools import wraps

def decorator_time(func):
    print("这是打印函数执行时间的装饰器")
    @wraps(func)
    def wrapper(*args,**kwargs):
        start = time.time()
        result1 = func(*args,**kwargs)
        end = time.time()
        execution_time = end - start
        print(f"{func.__name__}执行时间：{execution_time:.4f}秒")
        return result1
    return wrapper
def decorator_argsPrint(func):
    @wraps(func)
    def wrapper(*args,**kwargs):
        print(f"调用{func.__name__}函数，位置参数：{args}，关键字参数：{kwargs}")
        result2 = func(*args,**kwargs)
        return result2
    return wrapper

@decorator_time
@decorator_argsPrint
def add(x,y,z):
    time.sleep(1)
    print(z)
    return x + y ,z

result1 = add(5,3,"返回元组")  # 参数个数需要对应
print(f"加法结果：{result1}")
"""
输出
这是打印函数执行时间的装饰器
>>> result1 = add(5,3,"返回元组")  # 参数个数需要对应
调用add函数，位置参数：(5, 3, '返回元组')，关键字参数：{}
print(f"加法结果：{result1}")
返回元组
add执行时间：1.0036秒
>>> print(f"加法结果：{result1}")
加法结果：(8, '返回元组')
"""
```
### 装饰器的固定结构
```
from functools import wraps

def decorator_with_args(param):
    def actual_decorator(func):
        @wraps(func)
        def wrapper(*args,**kwargs):
            print(f"装饰器参数:{param}")
            return func(*args,**kwargs)
        return wrapper
    return actual_decorator

@decorator_with_args("配置参数")
def my_function():
    print("my_function 被调用")

my_function()
"""
输出
>>> my_function()
装饰器参数:配置参数
my_function 被调用
"""
```