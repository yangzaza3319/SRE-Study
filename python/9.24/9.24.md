# 迭代器和生成器
## 可迭代对象
1. 迭代的引入
> 使用`for i in xxx`对字符串、列表、元组、字典、集合进行循环取值的过程称为遍历，也叫迭代
```python
li = [1,2,3,'a','b','c']
for i in li:
    print(i)

str = "hello,world"
for j in str:
    print(j)

dic = {'name':'yc','age':18,'job':'teacher'}
for k,v in dic.items():
    print(k,v)

"""
输出
>>> li = [1,2,3,'a','b','c']
>>> for i in li:
...     print(i)
... 
1
2
3
a
b
c
>>> str = "hello,world"
for j in str:
...     print(j)
... 
h
e
l
l
o
,
w
o
r
l
d
dic = {'name':'yc','age':18,'job':'teacher'}
for k,v in dic.items():
...     print(k,v)
... 
name yc
age 18
job teacher
"""
```

## 可迭代对象的定义
> 可迭代对象是指能够通过迭代逐一返回其元素的对象
满足条件：
    - 实现`__iter__()`方法，返回一个可迭代对戏那个
    - 实现`__getitem__()`方法，支持从索引0开始的顺序访问

### 示例 判断是否为可迭代对象
```python
from collections.abc import Iterable

list = [1,2,3,4]
temple = (1,2,3,4)
dict = {1:2,3:4,5:6}
set = {1,2,3,4}
a = 100

print(isinstance(list,Iterable))
print(isinstance(temple,Iterable))
print(isinstance(dict,Iterable))
print(isinstance(set,Iterable))
print(isinstance(a,Iterable))

"""
输出
from collections.abc import Iterable
list = [1,2,3,4]
tumple = (1,2,3,4)
dict = {1:2,3:4,5:6}
set = {1,2,3,4}
a = 100
print(isinstance(list,Iterable))      # 列表可迭代
True 
print(isinstance(tumple,Iterable))    # 元组可迭代
True
print(isinstance(dict,Iterable))      # 字典可迭代
True
print(isinstance(set,Iterable))       # 集合可迭代
True
print(isinstance(a,Iterable))         # 整数不可迭代
False
"""
```
## 迭代器
1. 概览
> 1. 迭代器是一种用于遍历可迭代对象的对象，可以记录遍历的位置
> 2. 通过`__iter__`方法返回一个迭代器，迭代一个可迭代对象的时候，实际上是先获取该对象提供的一个迭代器，然后通过这个迭代器依次获取获取对象中的每一个数据
> 3. 迭代是访问集合的一种方式，迭代器是一个可以记住遍历的位置的对象；迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束（即迭代器只会往前而不会后退）
```
list = [1,2,3,4]
tuple = (1,2,3,4)
dict = {1:2,3:4}
set = {1,2,3,4}

print(dir(list))
print(dir(tuple))
print(dir(dict))
print(dir(set))
```
### 迭代器本质
>我们分析对可迭代对象进行迭代的过程，发现每迭代一次（即在`for...in`循环中每循环一次）都会返回对象中的下一条数据，一直向后读取数据知道迭代了所有数据后结束  
>在这个过程中，就有一个对象去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据，这个扮演数据迭代的对象称为**迭代器**
### 迭代器协议
> 迭代器遵循迭代协议，内部主要定义了`__iter__()`和`__next__()`两个方法
> - `__iter__()`方法用于初始化一个迭代器，返回迭代器本身
> - `__next__()`方法用于迭代下一个数据。当没有元素可返回时，抛出`StopIteration`异常
### 初始化迭代器
```
# 3.1 初始化迭代器
list1 = [1,2,3,'a','b','c']
list_iter = list1.__iter__()
item = list_iter.__next__()
print(item)                # 输出 1
item = list_iter.__next__()
print(item)                # 输出 2
item = list_iter.__next__()
print(item)                # 输出 3
item = list_iter.__next__()
print(item)                # 输出 a
item = list_iter.__next__()
print(item)                # 输出 b
item = list_iter.__next__()
print(item)                # 输出 c
item = list_iter.__next__()
print(item)               # 报错，抛出`StopIteration异常`

# 3.2 初始化迭代器（写法2）
list2 = [1,2,3,'a','b','c']

list_iter = list2.__iter__()
while True:
    try:
        print(next(list_iter))
    except StopIteration:
        print("迭代结束")
        break
```
### 判断对象是否为迭代器的方法
> 使用内置的`isinstance()`方法来判断某个对象是否是迭代器对象
```
from collections.abc import Iterator
list3 = [1,2,3,'a','b','c']

list_iter = list3.__iter__()

print(isinstance(list1,Iterator))           # 输出 False，list1非迭代器
print(isinstance(list_iter,Iterator))       # 输出True，list_iter为迭代器
print(isinstance(iter(list3),Iterator))     # 输出True，iter()函数返回迭代器
```
### for循环的本质
> for循环本质上是迭代器协议的一种具体体验（即提供了一个遍历的迭代元素的方法）
#### 工作原理
> 当使用`for`循环遍历一个可迭代对象时，实际上发生了以下几个步骤
1. 调用`__iter__()`
    `for`循环首先调用对象的`__iter__()`方法，获得一个迭代器对象
2. 调用`__next__()`
    `for`循环在迭代器上反复调用`__next__()`方法，以获取下一个元素
3. 处理`StopIteration`
    一旦`__next__()`方法抛出`StopIteration`异常，`for`循环停止迭代

## 生成器
> 生成器是Python中一种特殊的迭代器，允许你以一种简单而高效的方式生成序列

### 生成器的原理
- 状态保持
生成器通过`yield`语句保存函数的状态。在每次调用生成器时，函数会从上一个`yield`语句的下一行继续执行，而不仅仅是从函数的开始处执行
- 迭代器接口
生成器实现了迭代器协议，因此可以使用`for`循环进行遍历

### 生成器函数
- 生成器也是函数，但与普通函数不同的是，它使用`yield`关键字来返回值；每次调用生成器函数时，它会从上次`yield`的地方继续执行，直到遇到下一个`yield`或函数结束
- 调用生成器函数不会得到返回的具体的值，而是得到一个迭代器;每一次获取这个迭代器值，就能推动函数的执行，获取新的返回值；直到函数执行结束

```python
def numbers(n):
    """生成1到n的自然数"""
    for i in range(1,n+1):
        yield i

for i in numbers(10):
    print(i)
```

### 惰性求值
> 生成器在需要时生成值，而不是一次性计算和返回所有值（可以节省内存，特别是处理大型数据集时）
#### 案例卖包子（现包现卖）
```python
def produce():
    for i in range(1,100):
        yield f'第{i}笼包子出炉'

gen = produce()
print(gen.__next__()) # 小客户要了第1笼包子
print(gen.__next__()) # 小客户要了第2笼包子
print(gen.__next__()) # 小客户要了第3笼包子
print(gen.__next__()) # 小客户要了第4笼包子

for i in range(5):
    print(gen.__next__())
"""
输出
>>> gen = produce()
>>> print(gen.__next__()) # 小客户要了第1笼包子
第1笼包子出炉
>>> print(gen.__next__()) # 小客户要 了第2笼包子
第2笼包子出炉
>>> print(gen.__next__()) # 小客户要 了第3笼包子
第3笼包子出炉
>>> print(gen.__next__()) # 小客户要 了第4笼包子
第4笼包子出炉
>>> for i in range(5):
...     print(gen.__next__())
... 
第5笼包子出炉
第6笼包子出炉
第7笼包子出炉
第8笼包子出炉
第9笼包子出炉
"""
```
### send方法
1. `send`获取下一个的值效果和`next`基本一致
2. 在获取下一个值的时候，给上一个`yield`的位置传递一个数据
3. 使用`send`的注意事项
    - 第一次使用生成器的时候，用`next`获取下一个值
    - 最后一个`yield`不能接受外部的值

#### 案例
```
123
*** 1
我爱 Python
456
*** 2
```